'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SimpleSchema = require('../SimpleSchema');

function getMapIterator(obj, matchKey, keyAdjust) {
  return function (key) {
    var val = obj[key];
    if (val === undefined || val === null) return null;
    if (keyAdjust(key) === matchKey) return key;
  };
}

// Check for missing required values. The general logic is this:
// * If the operator is $unset or $rename, it's invalid.
// * If the value is null, it's invalid.
// * If the value is undefined and one of the following are true, it's invalid:
//     * We're validating a key of a sub-object.
//     * We're validating a key of an object that is an array item.
//     * We're validating a document (as opposed to a modifier).
//     * We're validating a key under the $set operator in a modifier, and it's an upsert.
function requiredValidator() {
  var _this = this;

  if (this.definition.optional) return;

  // If value is null, no matter what, we add required
  if (this.value === null) return _SimpleSchema.SimpleSchema.ErrorTypes.REQUIRED;

  // If operator would remove, we add required
  if (this.operator === '$unset' || this.operator === '$rename') return _SimpleSchema.SimpleSchema.ErrorTypes.REQUIRED;

  // The rest of these apply only if the value is undefined
  if (this.value !== undefined) return;

  // At this point, if it's a normal, non-modifier object, then a missing value is an error
  if (!this.operator) return _SimpleSchema.SimpleSchema.ErrorTypes.REQUIRED;

  // Everything beyond this point deals with modifier objects only

  // We can skip the required check for keys that are ancestors
  // of those in $set or $setOnInsert because they will be created
  // by MongoDB while setting.
  var obj = this.obj;
  var keysWithValueInSet = Object.keys(obj.$set || {}).map(getMapIterator(obj.$set, this.key + '.', function (k) {
    return k.slice(0, _this.key.length + 1);
  })).filter(function (v) {
    return !!v;
  });
  var keysWithValueInSetOnInsert = Object.keys(obj.$setOnInsert || {}).map(getMapIterator(obj.$setOnInsert, this.key + '.', function (k) {
    return k.slice(0, _this.key.length + 1);
  })).filter(function (v) {
    return !!v;
  });
  var willBeCreatedAutomatically = keysWithValueInSet.concat(keysWithValueInSetOnInsert).some(function (v) {
    return v;
  });
  if (willBeCreatedAutomatically) return;

  // In the case of $set and $setOnInsert, the value may be undefined here
  // but it is set in another operator. So check that first.
  var fieldInfo = this.field(this.key);
  if (fieldInfo.isSet && fieldInfo.value !== null) return;

  // Required if in an array or sub object
  if (this.isInArrayItemObject || this.isInSubObject) return _SimpleSchema.SimpleSchema.ErrorTypes.REQUIRED;

  // If we've got this far with an undefined $set or $setOnInsert value,
  // it's a required error.
  if (this.operator === '$set' || this.operator === '$setOnInsert') return _SimpleSchema.SimpleSchema.ErrorTypes.REQUIRED;
}

exports.default = requiredValidator;