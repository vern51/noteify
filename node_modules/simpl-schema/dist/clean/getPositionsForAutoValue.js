'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getPositionsForAutoValue;

var _mongoObject = require('mongo-object');

var _mongoObject2 = _interopRequireDefault(_mongoObject);

var _utility = require('../utility');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Extracts operator piece, if present, from position string
function extractOp(position) {
  var firstPositionPiece = position.slice(0, position.indexOf('['));
  return firstPositionPiece.substring(0, 1) === '$' ? firstPositionPiece : null;
}

function objectsThatKeyWillCreate(key) {
  var objs = [];

  do {
    var lastDotPosition = key.lastIndexOf('.');
    key = lastDotPosition === -1 ? '' : key.slice(0, lastDotPosition);
    if (key.length && !key.endsWith('.$')) objs.push(key);
  } while (key.length);

  return objs;
}

/**
 * A position is a place in the object where this field exists.
 * If no arrays are involved, then every field/key has at most 1 position.
 * If arrays are involved, then a field could have potentially unlimited positions.
 *
 * For example, the key 'a.b.$.c` would have these positions:
 *   `a[b][0][c]`
 *   `a[b][1][c]`
 *   `a[b][2][c]`
 *
 * For this object:
 * {
 *   a: {
 *     b: [
 *       { c: 1 },
 *       { c: 1 },
 *       { c: 1 },
 *     ],
 *   },
 * }
 */
function getPositionsForAutoValue(_ref) {
  var fieldName = _ref.fieldName,
      isModifier = _ref.isModifier,
      mongoObject = _ref.mongoObject;

  var positions = [];

  // Loop through every position
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    var _loop = function _loop() {
      var position = _step.value;

      var genericAffectedKey = mongoObject._genericAffectedKeys[position];
      var affectedKey = mongoObject._affectedKeys[position];
      var hasOperator = position.startsWith('$');

      // For pull, push, addToSet, and pop, mongoObject appends .0/.$ to the keys
      // but really we want to think of them as being related to the array itself
      // rather than the items. XXX It's possible that the change should be made in
      // mongo-object package, too.
      var isArrayOperator = ['$pull', '$push', '$addToSet', '$pop'].some(function (op) {
        return position.startsWith(op);
      });

      if (genericAffectedKey === fieldName || isArrayOperator && genericAffectedKey === fieldName + '.$') {
        positions.push({
          key: isArrayOperator ? affectedKey.slice(-2) : affectedKey,
          value: mongoObject.getValueForPosition(position),
          operator: extractOp(position),
          position: position
        });
      }

      // If the existing position is a parent and value is set, run for would-be
      // child position
      var parentPath = (0, _utility.getParentOfKey)(fieldName);
      if (genericAffectedKey === parentPath || genericAffectedKey + '.$' === parentPath) {
        var lastPart = (0, _utility.getLastPartOfKey)(fieldName, parentPath);
        var lastPartWithBraces = lastPart.replace(/\./g, '][');
        var childPosition = position + '[' + lastPartWithBraces + ']';
        positions.push({
          key: affectedKey + '.' + lastPart,
          value: mongoObject.getValueForPosition(childPosition),
          operator: extractOp(position),
          position: childPosition
        });
      }

      // If the parent path exists in the object, then we don't need to
      // do the next part
      if (mongoObject.getPositionsForGenericKey(parentPath).length) return 'continue';

      // If this position will implicitly create the parent object
      var objects = objectsThatKeyWillCreate(genericAffectedKey);
      if (parentPath.slice(-2) !== '.$' && objects.indexOf(parentPath) > -1) {
        if (hasOperator) {
          var operator = position.slice(0, position.indexOf('['));
          var next = position.slice(position.indexOf('[') + 1, position.indexOf(']'));
          var nextPieces = next.split('.');

          var newPieces = [];
          var newKey = void 0;
          while (nextPieces.length && newKey !== parentPath) {
            newPieces.push(nextPieces.shift());
            newKey = newPieces.join('.');
          }
          newKey = newKey + '.' + fieldName.slice(newKey.length + 1);

          var wouldBePosition = operator + '[' + newKey + ']';
          positions.push({
            key: _mongoObject2.default._positionToKey(wouldBePosition),
            value: mongoObject.getValueForPosition(wouldBePosition),
            operator: operator,
            position: wouldBePosition
          });
        } else {
          var _lastPart = (0, _utility.getLastPartOfKey)(fieldName, parentPath);
          var _lastPartWithBraces = _lastPart.replace(/\./g, '][');
          var _wouldBePosition = position.slice(0, position.lastIndexOf('[')) + '[' + _lastPartWithBraces + ']';
          positions.push({
            key: _mongoObject2.default._positionToKey(_wouldBePosition),
            value: mongoObject.getValueForPosition(_wouldBePosition),
            operator: null,
            position: _wouldBePosition
          });
        }
      }
    };

    for (var _iterator = Object.getOwnPropertyNames(mongoObject._genericAffectedKeys)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _ret = _loop();

      if (_ret === 'continue') continue;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (fieldName.indexOf('.') === -1 && positions.length === 0) {
    positions.push({
      key: fieldName,
      value: undefined,
      operator: isModifier ? '$set' : null,
      position: isModifier ? '$set[' + fieldName + ']' : fieldName
    });
  }

  return positions;
}